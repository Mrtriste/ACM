//http://blog.csdn.net/liuqiyao_01/article/details/8521776#_P01:_01背包问题
//http://blog.csdn.net/mu399/article/details/7722810

//f[i][v]= max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
//f[i][v]表示在背包容量为V、物品有0..i时，最多能装多少value
//注意f[i-1][v]与f[i-1][v-c[i]]+w[i]比，表示如果留个位置给i，即容量减去c[i]，能加上多少价值即w[i]，然后取较大的给新的f[i][v]

//优化空间复杂度从N*V为V
//for i=1..N
//    forv=V..0
//       f[v]=max{f[v],f[v-c[i]]+w[i]};
//为什么可以这样改，因为注意到随着物品向后的迭代，能装的价值越来越大，这是一个不逆的过程，所以更新为最大的即可
//为什么从V..0，注意到f[v-c[i]]，如果先更新位置小的f[v]，会影响到后面f[v-c[i]]的计算，否则一次物品会计算多次

//初始化问题
//如果要求背包恰好装满，则f[0]=0,f[1..V]=-1,不要求的话f[0..V]=0
//是否更新的条件加上f[v - w[i]] != -1是否成立，成立则更新，否则不更新
//原因是，现在的思想是每次更新的结果都是装进这个物品能使背包装满，如果在已装满的情况下，判断f[v - w[i]] 是否为-1
//如果为-1,也就是在留出i的容量时是装不满的，那把i装进去，也一定装不满，那就不更新
//注意这个的思想还是基于“在有0..i-1的物品，容量为v，正好装满背包时，用max{f[v],f[v-c[i]]+w[i]}来更新f[v]”