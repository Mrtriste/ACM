## 目录

- [基本模型](#基本模型)
- [具体问题](#具体问题)



### 套路

1. 找状态，定义一个“状态”来代表它的子问题， 并且找到它的解。

   ```注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。```

2. 推状态转移方程

3. 初始状态




## 复杂度与时间

1秒：约4*10^8次运算

对应：

o(1)：随便搞

o(logn)：只要不是高精度随便搞

o(n)：n<几百万

o(nlogn)：n<十几万~百万

o(n^2)：n<几千

o(n^3)：n<几百

o(2^n)：n:(10+)~(20+)




# 基本模型

## 数塔问题

自顶向下的分析，自底向上的计算。

```c++
dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + data[i][j]
```



## 最长公共子串

```c++
 if(s1[i-1]==s2[j-1])
   dp[i][j] = dp[i-1][j-1]+1;
 if(s1[i-1]!=s2[j-1])
   dp[i][j] = 0;
```



## 最长公共子序列

```c++
if(s1[i-1]==s2[j-1])
  dp[i][j] = dp[i-1][j-1]+1;
else
  dp[i][j] = max(dp[i][j-1],dp[i-1][j])
```



## 最长上升子序列





## 0-1背包



## 完全背包



## 多重背包



## 最大子段和



## 最大子段积



## 最大m字段和







# 具体问题

#### Martian Mining

[题目描述](http://acm.hdu.edu.cn/showproblem.php?pid=1578)

[结题报告](http://www.acmerblog.com/hdu-1578-Martian-Mining-2132.html)

d\[i\]\[j\][0]表示第(i,  j)格向左传送的情况下，矩形(0,0)-(i,j)所能收集到最多的矿石数，

d\[i\]\[j\][1]表示第(i,  j)格向上传送的情况下，矩形(0,0)-(i,j)所能收集到最多的矿石数。

设wes\[i\]\[j\]表示收集点在左边的矿石(i,0),(i,1)…(i,j)格共有多少，nor\[i\]\[j\]表示收集点在上边的矿石(0,j),(1,j),(2,j)…(i,j)格共有多少。

wes和nor数组递推易求，d数组的状态转移方程为：

d\[i\]\[j\][0] = wes[i\]\[j\] + max(d\[i-1]\[j][0], d\[i-1]\[j][1])，d\[i]\[j][1] = nor\[i][j] + max(d\[i]\[j-1][0], d\[i]\[j-1][1])。

####  

