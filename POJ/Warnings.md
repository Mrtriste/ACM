## 1166 The Clocks

暴力不仅只有搜索，还有枚举

记录状态的时候能用一个int能解决的 就不要用多个数组

hash记录状态要根据具体问题的特点，比如这题最多4^9种可能。



## 1256 Anagram

下一个排列



## 1321 棋盘问题

一个比较吊的DFS，他要考虑棋子不满的情况下有多个行可以选择。

在DFS()中选择下一次哪一行放棋子。

```c++
void DFS(int r, int c, int t){//t-th qizi
	if (t == k){
		cnt++;
		return;
	}
	for (int j = r + 1; j <= n - k + t;++j)//从下一行到最多能到的行
		for (int i = 0; i < n; ++i){
			if (judge(j, i))continue;
			col[i] = 1;
			DFS(j, i,t+1);
			col[i] = 0;
		}
}
```



## 1543 Perfect Cubes

n^4优化为n^2ln(n^2)

移项，用map.



## 1664 m个苹果放n个盘子

dp



## 1742 Coins

多重背包的二进制优化依然超时

考虑轮到第i个商品时，在已经能达到的价值上用第i种去添加。



## 1745 Divisibility

在n个数中间添加+或-，结果是否能被k整除。

对于每个新加进来的数，只需要记录他加进来的两种情况（+ or -）导致的余数能取哪些。



## 2182 Lost Cows

用到线段树保存每次更改后数列中第k大的数



## 2689 L-U的素数

两次筛选



## 2051 时间间隔

优先队列



## 2227 二维盛水

要用到BFS，一维的话只要找到某个点的左右分别的最大值的较小值即可。

其实与一维的思想是一样的，都是由周围最低的点决定某个方格的盛水量，一维是左右最大值的较小值。

二维的话就要找到它周围九个点的最小值，我们可以先将所有的边框放进优先队列，找到最小的那个边框，对于它（设为x）周围的四个区域（边框除外）：

1、如果某个区域 t 的高度比这个点小，那么这个区域一定可以放高度差h[x]-h[t]的水，然后把高度补到与该点相同，添加进优先队列，让它作为其他区域的边框，并且最多盛h[x]的水

2、如果某个区域t的高度比x大，那么它肯定不能盛水，但可以以它本身的高度作为边框，添加进队列。

因为我们每次找的是最小高度的点，那么它周围四个区域的盛水量一定正确。



## 2236  网络连接

并查集，修好一台电脑时，把在这个电脑连接范围的已修好的电脑加入集合中。



## 2247 Humble Number

丑数，1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, ... 

质数因子只有2,3,5,7，那么丑数一定是若干个2,3,5,7乘，即2^x\*3^y\*5^z*7^w

一开始只有1，然后由1分别去乘2,3,5,7，然后应该挑个最小的结果作为下一个丑数，因为2已经乘过1，下次2应该乘1后面的丑数，3,5,7还是乘1，就这样一步一步往后移。



## 2352 星星

线段树



## 2752 Seek the name

KMP中Next数组的运用



## 3461 Oulipo

KMP



## 2406 Power Strings &&1961 Period

KMP的Next数组求字符串循环节



## 2395Out of Hay 农场找最短的路

BFS 优先队列，每次找最小的路



## 1145 Tree Summing

将递归和scanf的特性用的淋漓尽致。

scanf(" (%d")是可以不读入int的，只要判断合法读入的变量个数即可，另外将后面的非法输入处理掉。



## 1195 Mobile Phones 

二维树状数组



## 1330 最近公共祖先

tarjian算法还没学



## 1451 T9

字典树，一开始纠结是根据26个字母建立节点还是根据8个数字

然后选择根据字母建，跟普通的字典树没区别，然后查询的时候又纠结了，对一串数字，总想着怎么利用这串数字之前的结果，发现很难做到o(len(数字串))，最终参考网上的，对每个数字串前缀单独DFS，反正长度100，还可以接受。

以后做这种题目先想好思路，如果复杂度能接受代码上就别写复杂的。



## 1724 ROADS

加了费用的最短路

此时就不需要



## 1703 Find them,Catch Them

带权并查集



## 1988 Cube Stacking

带权并查集

用到了两个权size[]和dis[]，子树的大小和到根的距离

find()时更新距离，Union()更新size和一个根的距离

```c++
void Make(){
	for (int i = 1; i <= 30000; ++i)
		p[i] = i, size[i] = 1;
	memset(dis, 0, sizeof(dis));
}

int find(int x){
	if (x != p[x]){
		int temp = p[x];
		p[x] = find(temp);
		dis[x] += dis[temp];
	}
	return p[x];
}

void Union(int x, int y){
	int a = find(x), b = find(y);
	p[a] = b;
	dis[a] += size[b];
	size[b] += size[a];
	size[a] = 0;
}
```



## 1661 Help Jimmy

n个板子，从空中跳下，高度不能大于max，找最小时间。

dp\[i]\[j]:第i个板子j侧到达地面的最短时间。j=0,1

每个板子有两种情况，底下有平台，或者没有平台。



## 2010 Moo University - Financial Aid

a[i]前面k个数的和的最小值，优先队列。

到现在都没弄懂在循环里打印break和在外面打印有什么区别。



## 1018 Communication System

很经典的一道可以用队列实现的动态规划

因为每种物品有m个厂商，这是属于m种的问题，如果用数组保存结果可能会很浪费，每次要遍历最大的结果次，但是用队列保存的话只要遍历m次。



## 1050 To the max

最大子矩阵和

转化为数列的最大字段和，o(n^3)



## 1083 Moving Tables

又一次将最大上升子序列和数列中出现最多次数的数的次数搞混。

移桌子，只要走廊上没有同时出现在一段的即可，也就是用的最多的那段走廊用的次数即可。



## 1088 滑雪

动态规划、记忆化搜索

1. 可以记忆化搜索，DFS会超时，那么把DFS过的答案直接记录下来

```c++
int DFS(int x,int y){
	if (dp[x][y] > 0)return dp[x][y];
	int xx, yy;
	int mmax = 1;
	for (int i = 0; i < 4; ++i){
		xx = x + dir[i][0], yy = y + dir[i][1];
		if (xx < 0 || yy < 0 || xx >= R || yy >= C)continue;
		if (a[x][y] > a[xx][yy])mmax = max(DFS(xx, yy) + 1, mmax);
	}
	dp[x][y] = mmax;
	return mmax;
}
```

2. 动态规划

将这些数先从小到大放到优先队列中，每次取出最小的，向四个方向比较，找到最大的加1

```c++
		while (!q.empty()){
			cur = q.top(), q.pop();
			int m = dp[cur.x][cur.y];
			for (int i = 0; i < 4; ++i){
				xx = cur.x + dir[i][0], yy = cur.y + dir[i][1];
				if (xx < 0 || yy < 0 || xx >= R || yy >= C)continue;
				if (a[cur.x][cur.y] > a[xx][yy])m = max(dp[cur.x][cur.y] + dp[xx][yy], m);
			}
			dp[cur.x][cur.y] = m;
			mmax = max(mmax, m);
		}
```



